"use strict";const aws=require("aws-sdk"),defaultSleep=function(a){return new Promise(b=>setTimeout(b,a))};let defaultResponseURL,defaultLogGroup,defaultLogStream,waiter,domainTypes,sleep=defaultSleep,random=Math.random,maxAttempts=10,report=function(a,b,c,d,e,f){return new Promise((g,h)=>{const i=require("https"),{URL:j}=require("url");let k=JSON.stringify({Status:c,Reason:f,PhysicalResourceId:d||b.logStreamName,StackId:a.StackId,RequestId:a.RequestId,LogicalResourceId:a.LogicalResourceId,Data:e});const l=new j(a.ResponseURL||defaultResponseURL),m={hostname:l.hostname,port:443,path:l.pathname+l.search,method:"PUT",headers:{"Content-Type":"","Content-Length":k.length}};i.request(m).on("error",h).on("response",a=>{a.resume(),400<=a.statusCode?h(new Error(`Error ${a.statusCode}: ${a.statusMessage}`)):g()}).end(k,"utf8")})};const aliasesChanged=function(a,b){if(!a)return!0;let c=getAllAliases(a.Aliases),d=[...c].filter(function(a){return!b.has(a)}),e=[...b].filter(function(a){return!c.has(a)});return e.length+d.length},requestCertificate=async function(a,b,c,d,e,f,g){const h=require("crypto");return g.requestCertificate({DomainName:d,SubjectAlternativeNames:f,IdempotencyToken:h.createHash("sha256").update(a).digest("hex").substr(0,32),ValidationMethod:"DNS",Tags:[{Key:"copilot-application",Value:b},{Key:"copilot-environment",Value:c}]}).promise()},waitForValidationOptionsToBeReady=async function(a,b,c){let d,e;const f=b.length;for(e=0;e<maxAttempts;e++){const{Certificate:b}=await c.describeCertificate({CertificateArn:a}).promise();d=b.DomainValidationOptions||[];let g=0;for(const a of d)a.ResourceRecord&&g++;if(g===f)break;const h=Math.pow(2,e);await sleep(50*(random()*h)+150*h)}if(e===maxAttempts)throw new Error(`DescribeCertificate did not contain DomainValidationOptions after ${maxAttempts} tries.`);return d},validateCertificate=async function(a,b,c,d,e,f){await updateHostedZoneRecords("UPSERT",a,b,c,d),await f.waitFor("certificateValidated",{$waiter:{delay:30,maxAttempts:19},CertificateArn:e}).promise()},updateHostedZoneRecords=async function(a,b,c,d,e){const f=[];for(const g of b){const b=await getDomainType(g.DomainName);b===domainTypes.EnvDomainZone?f.push(validateDomain({route53:c,record:g.ResourceRecord,action:a,domainName:"",hostedZoneId:e})):b===domainTypes.AppDomainZone?f.push(validateDomain({route53:d,record:g.ResourceRecord,action:a,domainName:b.domain})):b===domainTypes.RootDomainZone?f.push(validateDomain({route53:d,record:g.ResourceRecord,action:a,domainName:b.domain})):void 0}return Promise.all(f)},deleteHostedZoneRecords=async function(a,b,c,d,e,f,g){let h={},i=[],j=!1;for(;!j;){const a=await f.listCertificates(h).promise();for(const d of a.CertificateSummaryList||[]){if(d.DomainName!==c||d.CertificateArn===b)continue;const{Certificate:a}=await f.describeCertificate({CertificateArn:d.CertificateArn}).promise();i=a.DomainValidationOptions||[],j=!0;break}if(!a.NextToken)break;h.NextToken=a.NextToken}const k=new Set(i.map(a=>a.DomainName)),l=[];for(const h of a)k.has(h.DomainName)||l.push(h);const m=[];let n=new Set;for(const h of l){let a=`${h.ResourceRecord.Name} ${h.ResourceRecord.Value}`;n.has(a)||(n.add(a),m.push(h))}await updateHostedZoneRecords("DELETE",m,d,e,g)},validateDomain=async function({route53:a,record:b,action:c,domainName:d,hostedZoneId:e}){if(!e){const b=await a.listHostedZonesByName({DNSName:d,MaxItems:"1"}).promise();if(!b.HostedZones||0===b.HostedZones.length)throw new Error(`Couldn't find any Hosted Zone with DNS name ${d}.`);e=b.HostedZones[0].Id.split("/").pop()}console.log(`${c} DNS record into Hosted Zone ${e}: ${b.Name} ${b.Type} ${b.Value}`);const f=await updateRecords(a,e,c,b.Name,b.Type,b.Value);await waitForRecordChange(a,f.ChangeInfo.Id)},deleteCertificate=async function(a,b,c,d,e){const[f,g,h]=clients(c,e);try{console.log(`Waiting for certificate ${a} to become unused`);let c,e;for(let b=0;b<maxAttempts;b++){const{Certificate:b}=await f.describeCertificate({CertificateArn:a}).promise();c=b.InUseBy||[],e=b.DomainValidationOptions||[];let d=!1;for(const a of e){if(!a.ResourceRecord){d=!1;break}d=!0}if(!d||c.length)await sleep(3e4);else break}if(c.length)throw new Error(`Certificate still in use after checking for ${maxAttempts} attempts.`);await deleteHostedZoneRecords(e,a,b,g,h,f,d),await f.deleteCertificate({CertificateArn:a}).promise()}catch(a){if("ResourceNotFoundException"!==a.name)throw a}},waitForRecordChange=function(a,b){return a.waitFor("resourceRecordSetsChanged",{$waiter:{delay:30,maxAttempts:10},Id:b}).promise()},updateRecords=function(a,b,c,d,e,f){return a.changeResourceRecordSets({ChangeBatch:{Changes:[{Action:c,ResourceRecordSet:{Name:d,Type:e,TTL:60,ResourceRecords:[{Value:f}]}}]},HostedZoneId:b}).promise()},getAllAliases=function(a){let b;try{b=JSON.parse(a||"{}")}catch(b){throw new Error(`Cannot parse ${a} into JSON format.`)}let c=[];for(const[d,e]of Object.entries(b))c.push(...e);return new Set(c.filter(function(a){return getDomainType(a)!==domainTypes.OtherDomainZone}))},getDomainType=function(a){return domainTypes.EnvDomainZone.regex.test(a)?domainTypes.EnvDomainZone:domainTypes.AppDomainZone.regex.test(a)?domainTypes.AppDomainZone:domainTypes.RootDomainZone.regex.test(a)?domainTypes.RootDomainZone:domainTypes.OtherDomainZone},clients=function(a,b){const c=new aws.ACM({region:a}),d=new aws.Route53,e=new aws.Route53({credentials:new aws.ChainableTemporaryCredentials({params:{RoleArn:b},masterCredentials:new aws.EnvironmentCredentials("AWS")})});return waiter&&(d.waitFor=e.waitFor=c.waitFor=waiter),[c,d,e]};exports.certificateRequestHandler=async function(a,b){let c={},d=a.PhysicalResourceId;const e=a.ResourceProperties,[f,g,h]=[e.AppName,e.EnvName,e.DomainName];domainTypes={EnvDomainZone:{regex:new RegExp(`^([^\.]+\.)?${g}.${f}.${h}`),domain:`${g}.${f}.${h}`},AppDomainZone:{regex:new RegExp(`^([^\.]+\.)?${f}.${h}`),domain:`${f}.${h}`},RootDomainZone:{regex:new RegExp(`^([^\.]+\.)?${h}`),domain:`${h}`},OtherDomainZone:{}};let i=`${e.EnvName}.${e.AppName}.${e.DomainName}`,j=getAllAliases(e.Aliases);const k=new Set([i,`*.${i}`]);for(const c of j)k.add(c);const l=[...k],[m,n,o]=clients(e.Region,e.RootDNSRole);try{let f={},g={};switch(a.RequestType){case"Create":f=await requestCertificate(a.RequestId,e.AppName,e.EnvName,i,j,l,m),c.Arn=d=f.CertificateArn,g=await waitForValidationOptionsToBeReady(f.CertificateArn,l,m),await validateCertificate(g,n,o,e.EnvHostedZoneId,f.CertificateArn,m);break;case"Update":if(!aliasesChanged(a.OldResourceProperties,j))break;f=await requestCertificate(a.RequestId,e.AppName,e.EnvName,i,j,l,m),c.Arn=d=f.CertificateArn,g=await waitForValidationOptionsToBeReady(f.CertificateArn,l,m),await validateCertificate(g,n,o,e.EnvHostedZoneId,f.CertificateArn,m);break;case"Delete":d.startsWith("arn:")&&(await deleteCertificate(d,i,e.Region,e.EnvHostedZoneId,e.RootDNSRole));break;default:throw new Error(`Unsupported request type ${a.RequestType}`);}await report(a,b,"SUCCESS",d,c)}catch(c){console.log(`Caught error ${c}.`),await report(a,b,"FAILED",d,null,`${c.message} (Log: ${defaultLogGroup||b.logGroupName}/${defaultLogStream||b.logStreamName})`)}},exports.withDefaultResponseURL=function(a){defaultResponseURL=a},exports.withWaiter=function(a){waiter=a},exports.withSleep=function(a){sleep=a},exports.reset=function(){sleep=defaultSleep,random=Math.random,waiter=void 0,maxAttempts=10},exports.withRandom=function(a){random=a},exports.withMaxAttempts=function(a){maxAttempts=a},exports.withDefaultLogStream=function(a){defaultLogStream=a},exports.withDefaultLogGroup=function(a){defaultLogGroup=a};
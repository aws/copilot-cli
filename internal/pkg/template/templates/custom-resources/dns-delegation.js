"use strict";const aws=require("aws-sdk");let defaultResponseURL,defaultLogGroup,defaultLogStream,report=function(a,b,c,d,e,f){return new Promise((g,h)=>{const i=require("https"),{URL:j}=require("url");var k=JSON.stringify({Status:c,Reason:f,PhysicalResourceId:d||b.logStreamName,StackId:a.StackId,RequestId:a.RequestId,LogicalResourceId:a.LogicalResourceId,Data:e});const l=new j(a.ResponseURL||defaultResponseURL),m={hostname:l.hostname,port:443,path:l.pathname+l.search,method:"PUT",headers:{"Content-Type":"","Content-Length":k.length}};i.request(m).on("error",h).on("response",a=>{a.resume(),400<=a.statusCode?h(new Error(`Server returned error ${a.statusCode}: ${a.statusMessage}`)):g()}).end(k,"utf8")})};const createSubdomainInRoot=async function(a,b,c,d,e){const f=new aws.Route53({credentials:new aws.ChainableTemporaryCredentials({params:{RoleArn:e},masterCredentials:new aws.EnvironmentCredentials("AWS")})}),g=await f.listHostedZonesByName({DNSName:b}).promise();if(!g.HostedZones||0==g.HostedZones.length)throw new Error(`Couldn't find any hostedzones with DNS name ${b}. Request ${a}`);const h=g.HostedZones[0],i=h.Id.split("/").pop(),j=await f.changeResourceRecordSets({ChangeBatch:{Changes:[recordChangeAction("UPSERT",c,"NS",d.map(a=>({Value:a})))]},HostedZoneId:i}).promise();console.log(`Created recordset in hostedzone ${i} for ${c}`),await waitForRecordSetChange(f,j.ChangeInfo.Id)},deleteSubdomainInRoot=async function(a,b,c,d){const e=new aws.Route53({credentials:new aws.ChainableTemporaryCredentials({params:{RoleArn:d},masterCredentials:new aws.EnvironmentCredentials("AWS")})}),f=await e.listHostedZonesByName({DNSName:b}).promise();if(!f.HostedZones||0==f.HostedZones.length)throw new Error(`Couldn't find any hostedzones with DNS name ${b}. Request ${a}`);const g=f.HostedZones[0],h=g.Id.split("/").pop(),i=await e.listResourceRecordSets({HostedZoneId:h,MaxItems:"1",StartRecordName:c,StartRecordType:"NS"}).promise();if(!i.ResourceRecordSets||0==i.ResourceRecordSets)return c;const j=i.ResourceRecordSets[0];if(`${c}.`!==j.Name||"NS"!==j.Type)return c;console.log(`Deleting recordset ${j.Name}`);const k=await e.changeResourceRecordSets({ChangeBatch:{Changes:[recordChangeAction("DELETE",c,"NS",j.ResourceRecords)]},HostedZoneId:h}).promise();return await waitForRecordSetChange(e,k.ChangeInfo.Id),c},recordChangeAction=function(a,b,c,d){return{Action:a,ResourceRecordSet:{Name:b,Type:c,TTL:60,ResourceRecords:d}}},waitForRecordSetChange=function(a,b){return a.waitFor("resourceRecordSetsChanged",{$waiter:{delay:30,maxAttempts:10},Id:b}).promise()};exports.domainDelegationHandler=async function(a,b){const c=a.ResourceProperties,d=c.SubdomainName;try{switch(a.RequestType){case"Create":case"Update":await createSubdomainInRoot(a.RequestId,c.DomainName,c.SubdomainName,c.NameServers,c.RootDNSRole);break;case"Delete":await deleteSubdomainInRoot(a.RequestId,c.DomainName,c.SubdomainName,c.RootDNSRole);break;default:throw new Error(`Unsupported request type ${a.RequestType}`);}await report(a,b,"SUCCESS",d,{})}catch(c){console.log(`Caught error ${c}.`),console.log(c),await report(a,b,"FAILED",d,null,`${c.message} (Log: ${defaultLogGroup||b.logGroupName}/${defaultLogStream||b.logStreamName})`)}},exports.withDefaultResponseURL=function(a){defaultResponseURL=a},exports.withDefaultLogStream=function(a){defaultLogStream=a},exports.withDefaultLogGroup=function(a){defaultLogGroup=a};
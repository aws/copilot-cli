"use strict";const AWS=require("aws-sdk"),DOMAIN_STATUS_PENDING_VERIFICATION="pending_certificate_dns_validation",DOMAIN_STATUS_ACTIVE="active",DOMAIN_STATUS_DELETE_FAILED="delete_failed",ATTEMPTS_WAIT_FOR_PENDING=10,ATTEMPTS_WAIT_FOR_DISASSOCIATED=20;let appRoute53Client,appRunnerClient,appHostedZoneID,defaultSleep=function(a){return new Promise(b=>setTimeout(b,a))},sleep=defaultSleep;function report(a,b,c,d,e,f){return new Promise((g,h)=>{const i=require("https"),{URL:j}=require("url");let k=`${f} (Log: ${b.logGroupName}/${b.logStreamName})`;var l=JSON.stringify({Status:c,Reason:k,PhysicalResourceId:d||b.logStreamName,StackId:a.StackId,RequestId:a.RequestId,LogicalResourceId:a.LogicalResourceId,Data:e});const m=new j(a.ResponseURL),n={hostname:m.hostname,port:443,path:m.pathname+m.search,method:"PUT",headers:{"Content-Type":"","Content-Length":l.length}};i.request(n).on("error",h).on("response",a=>{a.resume(),400<=a.statusCode?h(new Error(`Error ${a.statusCode}: ${a.statusMessage}`)):g()}).end(l,"utf8")})}exports.handler=async function(a,b){const c=a.ResourceProperties,[d,e,f,g]=[c.ServiceARN,c.AppDNSRole,c.CustomDomain,c.AppDNSName],h=`/associate-domain-app-runner/${f}`;let i=async function(){switch(appRoute53Client=new AWS.Route53({credentials:new AWS.ChainableTemporaryCredentials({params:{RoleArn:e},masterCredentials:new AWS.EnvironmentCredentials("AWS")})}),appRunnerClient=new AWS.AppRunner,appHostedZoneID=await domainHostedZoneID(g),a.RequestType){case"Create":case"Update":await addCustomDomain(d,f);break;case"Delete":await removeCustomDomain(d,f),await waitForCustomDomainToBeDisassociated(d,f);break;default:throw new Error(`Unsupported request type ${a.RequestType}`);}};try{await Promise.race([exports.deadlineExpired(),i()]),await report(a,b,"SUCCESS",h)}catch(c){console.log(`Caught error for service ${d}: ${c.message}`),await report(a,b,"FAILED",h,null,c.message)}},exports.deadlineExpired=function(){return new Promise(function(a,b){setTimeout(b,870000,new Error(`Lambda took longer than 14.5 minutes to update custom domain`))})};async function domainHostedZoneID(a){const b=await appRoute53Client.listHostedZonesByName({DNSName:a,MaxItems:"1"}).promise();if(!b.HostedZones||0===b.HostedZones.length)throw new Error(`couldn't find any Hosted Zone with DNS name ${a}`);return b.HostedZones[0].Id.split("/").pop()}async function addCustomDomain(a,b){let c;try{c=await appRunnerClient.associateCustomDomain({DomainName:b,ServiceArn:a}).promise()}catch(a){const c=a.message.includes(`${b} is already associated with`);if(!c)throw a}return c||(c=await appRunnerClient.describeCustomDomains({ServiceArn:a}).promise()),Promise.all([updateCNAMERecordAndWait(b,c.DNSTarget,appHostedZoneID,"UPSERT"),validateCertForDomain(a,b)])}async function getDomainInfo(a,b){for(let c={ServiceArn:a};;){const a=await appRunnerClient.describeCustomDomains(c).promise();for(const c of a.CustomDomains)if(c.DomainName===b)return c;if(!a.NextToken)throw new NotAssociatedError(`domain ${b} is not associated`);c.NextToken=a.NextToken}}async function validateCertForDomain(a,b){let c,d;for(c=0;c<ATTEMPTS_WAIT_FOR_PENDING;c++){const c=await getDomainInfo(a,b).catch(a=>{throw new Error(`update validation records for domain ${b}: `+a.message)});if(d=c.Status,!domainValidationRecordReady(c)){await sleep(3e3);continue}const e=c.CertificateValidationRecords;let f=[];for(const a of e)f.push(updateCNAMERecordAndWait(a.Name,a.Value,appHostedZoneID,"UPSERT").catch(a=>{throw new Error(`update validation records for domain ${b}: `+a.message)}));return Promise.all(f)}if(c===ATTEMPTS_WAIT_FOR_PENDING)throw new Error(`update validation records for domain ${b}: fail to wait for state ${DOMAIN_STATUS_PENDING_VERIFICATION}, stuck in ${d}`)}function domainValidationRecordReady(a){return!(a.Status!==DOMAIN_STATUS_PENDING_VERIFICATION)||!!(a.Status===DOMAIN_STATUS_ACTIVE&&a.CertificateValidationRecords&&3===a.CertificateValidationRecords.length)}async function removeCustomDomain(a,b){let c;try{c=await appRunnerClient.disassociateCustomDomain({DomainName:b,ServiceArn:a}).promise()}catch(a){if(a.message.includes(`No custom domain ${b} found for the provided service`))return;throw a}return Promise.all([updateCNAMERecordAndWait(b,c.DNSTarget,appHostedZoneID,"DELETE"),removeValidationRecords(c.CustomDomain)])}async function removeValidationRecords(a){const b=a.CertificateValidationRecords;let c=[];for(const d of b)c.push(updateCNAMERecordAndWait(d.Name,d.Value,appHostedZoneID,"DELETE").catch(b=>{throw new Error(`delete validation records for domain ${a.DomainName}: `+b.message)}));return Promise.all(c)}async function waitForCustomDomainToBeDisassociated(a,b){let c;for(let d=0;d<ATTEMPTS_WAIT_FOR_DISASSOCIATED;d++){let e;try{e=await getDomainInfo(a,b)}catch(a){if(a instanceof NotAssociatedError)return;throw new Error(`wait for domain ${b} to be unused: `+a.message)}if(c=e.Status,c===DOMAIN_STATUS_DELETE_FAILED)throw new Error(`fail to disassociate domain ${b}: domain status is ${DOMAIN_STATUS_DELETE_FAILED}`);const f=Math.pow(2,d);await sleep(50*(Math.random()*f)+150*f)}throw console.log(`Fail to wait for the domain status to be disassociated. The last reported status of domain ${b} is ${c}`),new Error(`fail to wait for domain ${b} to be disassociated`)}async function updateCNAMERecordAndWait(a,b,c,d){let e;try{e=await appRoute53Client.changeResourceRecordSets({ChangeBatch:{Changes:[{Action:d,ResourceRecordSet:{Name:a,Type:"CNAME",TTL:60,ResourceRecords:[{Value:b}]}}]},HostedZoneId:c}).promise()}catch(b){let c=/Tried to delete resource record set \[name='.*', type='CNAME'] but it was not found/;if("DELETE"===d&&-1!==b.message.search(c))return;throw new Error(`update record ${a}: `+b.message)}await appRoute53Client.waitFor("resourceRecordSetsChanged",{$waiter:{delay:30,maxAttempts:10},Id:e.ChangeInfo.Id}).promise().catch(b=>{throw new Error(`update record ${a}: wait for record sets change for ${a}: `+b.message)})}function NotAssociatedError(a=""){this.message=a}NotAssociatedError.prototype=Error.prototype,exports.domainStatusPendingVerification=DOMAIN_STATUS_PENDING_VERIFICATION,exports.waitForDomainStatusPendingAttempts=ATTEMPTS_WAIT_FOR_PENDING,exports.waitForDomainToBeDisassociatedAttempts=ATTEMPTS_WAIT_FOR_DISASSOCIATED,exports.withSleep=function(a){sleep=a},exports.reset=function(){sleep=defaultSleep},exports.withDeadlineExpired=function(a){exports.deadlineExpired=a};